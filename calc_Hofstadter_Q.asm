; ========================================================================
; 程序功能：计算Hofstadter Q序列第n项
; 输入：n 存储在 x3100
; 输出：Q(n) 存储在 x3101
; 数组存储：x3201=Q(1), x3202=Q(2), ..., x3200+k=Q(k)
; 递推公式：Q(n) = Q(n - Q(n-1)) + Q(n - Q(n-2))
;           Q(1) = 1, Q(2) = 1
; ========================================================================
    .ORIG x3000

; ========================================================================
; 主程序入口
; ========================================================================
MAIN
    ; 1. 读取输入n
    LDI R0, ADDR_N          ; R0 = n (从x3100读取)
    ST R0, SAVE_N           ; 保存n供后续使用
    
    ; 2. 初始化Q(1)=1, Q(2)=1
    AND R1, R1, #0          ; R1 = 0
    ADD R1, R1, #1          ; R1 = 1
    LD R2, BASE_ADDR        ; R2 = x3200 (数组基址)
    STR R1, R2, #1          ; Q(1) = 1 存入x3201
    STR R1, R2, #2          ; Q(2) = 1 存入x3202
    
    ; 3. 判断n是否<=2
    LD R0, SAVE_N           ; R0 = n
    ADD R3, R0, #-2         ; R3 = n - 2
    BRnz SAVE_RESULT        ; 如果n<=2, 结果已经在数组中，直接跳转到保存结果
    
    ; 4. 从i=3开始循环计算到n
    AND R0, R0, #0          
    ADD R0, R0, #3          ; R0 = i = 3 (循环变量)
    
LOOP
    ST R0, SAVE_I           ; 保存当前循环变量i
    
    ; ==================== 计算 Q(i - Q(i-1)) ====================
    ; Step 1: 获取Q(i-1)
    LD R0, SAVE_I           ; R0 = i
    ADD R0, R0, #-1         ; R0 = i-1
    LD R2, BASE_ADDR        ; R2 = x3200
    ADD R2, R2, R0          ; R2 = x3200 + (i-1)
    LDR R1, R2, #0          ; R1 = Q(i-1)
    
    ; Step 2: 计算 i - Q(i-1)
    LD R0, SAVE_I           ; R0 = i
    NOT R1, R1              ; R1 = ~Q(i-1)
    ADD R1, R1, #1          ; R1 = -Q(i-1)
    ADD R0, R0, R1          ; R0 = i - Q(i-1)
    
    ; Step 3: 获取Q(i - Q(i-1))
    LD R2, BASE_ADDR        ; R2 = x3200
    ADD R2, R2, R0          ; R2 = x3200 + (i - Q(i-1))
    LDR R3, R2, #0          ; R3 = Q(i - Q(i-1))
    ST R3, TEMP1            ; 保存第一项 
    
    ; ==================== 计算 Q(i - Q(i-2)) ====================
    ; Step 1: 获取Q(i-2)
    LD R0, SAVE_I           ; R0 = i
    ADD R0, R0, #-2         ; R0 = i-2
    LD R2, BASE_ADDR        ; R2 = x3200
    ADD R2, R2, R0          ; R2 = x3200 + (i-2)
    LDR R1, R2, #0          ; R1 = Q(i-2)
    
    ; Step 2: 计算 i - Q(i-2)
    LD R0, SAVE_I           ; R0 = i
    NOT R1, R1              ; R1 = ~Q(i-2)
    ADD R1, R1, #1          ; R1 = -Q(i-2)
    ADD R0, R0, R1          ; R0 = i - Q(i-2)
    
    ; Step 3: 获取Q(i - Q(i-2))
    LD R2, BASE_ADDR        ; R2 = x3200
    ADD R2, R2, R0          ; R2 = x3200 + (i - Q(i-2))
    LDR R4, R2, #0          ; R4 = Q(i - Q(i-2))
    
    ; ==================== 计算Q(i)并保存 ====================
    LD R3, TEMP1            ; R3 = Q(i - Q(i-1))
    ADD R5, R3, R4          ; R5 = Q(i - Q(i-1)) + Q(i - Q(i-2)) = Q(i)
    
    ; 保存Q(i)到数组
    LD R0, SAVE_I           ; R0 = i
    LD R2, BASE_ADDR        ; R2 = x3200
    ADD R2, R2, R0          ; R2 = x3200 + i
    STR R5, R2, #0          ; Q(i) 存入数组
    
    ; ==================== 循环控制 ====================
    LD R0, SAVE_I           ; R0 = i
    ADD R0, R0, #1          ; i = i + 1
    
    ; 判断是否 i <= n
    LD R1, SAVE_N           ; R1 = n
    NOT R0, R0              ; R0 = ~i
    ADD R0, R0, #1          ; R0 = -i
    ADD R1, R1, R0          ; R1 = n - i
    BRn SAVE_RESULT         ; 如果n < i，退出循环
    
    LD R0, SAVE_I           ; 恢复i
    ADD R0, R0, #1          ; i = i + 1
    BRnzp LOOP              ; 继续循环
    
; ========================================================================
; 保存结果到x3101
; ========================================================================
SAVE_RESULT
    LD R0, SAVE_N           ; R0 = n
    LD R2, BASE_ADDR        ; R2 = x3200
    ADD R2, R2, R0          ; R2 = x3200 + n
    LDR R1, R2, #0          ; R1 = Q(n)
    STI R1, ADDR_RESULT     ; 将Q(n)存入x3101
    HALT                    ; 程序结束

; ========================================================================
; 数据区
; ========================================================================
SAVE_N      .FILL x0000     ; 保存输入的n
SAVE_I      .FILL x0000     ; 保存循环变量i
TEMP1       .FILL x0000     ; 临时保存第一项
BASE_ADDR   .FILL x3200     ; 数组基址
ADDR_N      .FILL x3100     ; n的存储地址
ADDR_RESULT .FILL x3101     ; 结果的存储地址

    .END